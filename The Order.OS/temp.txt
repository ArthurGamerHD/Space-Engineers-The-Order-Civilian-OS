/*
 * README
 * 
 * Put "[T.OS:(Unique Name)]" in a Screen, some Tool (Welder, Grinder or Drill) and Some kind of Ship Controller 
 * If you want to use more Screens, put ONLY on the Top Left One, Run the Script, and set te ammout of Rows and Cols on the screen Custom Data
 * (Tip, you can use Wide screens and Rotate in the screen Terminal to get better Resolution with less screens)
 * 
 * You can Customize your Faction logo and Color Scheme bellow;
 *
 * Current Commands:
 * NEW:DIAG
 * NEW:MATH
 * NEW:MEDIA
 * NEW:DEBUG
 */



class BSoD
{
    float scale = 1;
    Vector2 centerPos = new Vector2();
    MultiScreenSpriteSurface frame;
    public BSoD(Workstation Workstation)
    {
        var UWide = Workstation.Screen.TextureSize.X >= 2 * Workstation.Screen.TextureSize.Y;
        var Wide = Workstation.Screen.TextureSize.X > Workstation.Screen.TextureSize.Y;
        scale = (UWide ? Workstation.Scale*2 : Workstation.Scale);
        var W = Color.White;
        var B = Color.Blue;
        frame = Workstation.Screen;
        S(0f, 0f, Workstation.Screen.TextureSize.X, Workstation.Screen.TextureSize.Y, B);
        var text = $"Your Station ran into a problem{(Wide ? " " : "\n")}and needs to Restart.\nRun the Programable Block with\nthis argument: RESTART {{StationID}}";
        frame.Add(new MySprite(SpriteType.TEXT, text, new Vector2(5, 75)* scale, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 1f*scale));
        text = $"For more information about this issue, visit \nhttps://docs.microsoft.com/dotnet/csharp/language-refere{(Wide ? "" : "\n")}nce/language-specification/exceptions \nOr Read this QR code";
        frame.Add(new MySprite(SpriteType.TEXT, text, new Vector2(120, 270)*scale, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, .5f* scale));
        text = $"If you call a support person,{(Wide ? " " : "\n")}give them this info:\nException code: {{Exeption}}";
        frame.Add(new MySprite(SpriteType.TEXT, text, new Vector2(120, Wide ? 320 : 330) * scale, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, .5f * scale));
        var QR = new RectangleF(10*scale, 270 * scale, 100 * scale, 100 * scale);
        centerPos = QR.Center;
        scale /= 5;
        S(0f, 0f, 52f, 52f, W); S(0f, 0f, 50f, 50f, B); S(18f, -18f, 10f, 10f, W); S(-18f, -18f, 10f, 10f, W); S(-18f, 18f, 10f, 10f, W); S(18f, -18f, 6f, 6f, B); S(-18f, -18f, 6f, 6f, B);
        S(-18f, 18f, 6f, 6f, B); S(17f, -10f, 16f, 2f, W); S(-17f, -10f, 16f, 2f, W); S(-17f, 10f, 16f, 2f, W); S(10f, -17f, 2f, 16f, W); S(-10f, -17f, 2f, 16f, W); S(-4f, 14f, 2f, 2f, W);
        S(-10f, 17f, 2f, 16f, W); S(-6f, 17f, 2f, 4f, W); S(-3f, 21f, 4f, 8f, W); S(7f, 20f, 4f, 2f, W); S(1f, -9f, 4f, 4f, W); S(1f, -3f, 4f, 4f, W); S(22f, -8f, 2f, 2f, W); S(-8f, 22f, 2f, 2f, W);
        S(24f, -7f, 2f, 4f, W); S(24f, 10f, 2f, 2f, W); S(-2f, 5f, 2f, 8f, W); S(9f, -2f, 4f, 2f, W); S(14f, 1f, 2f, 4f, W); S(24f, -1f, 2f, 4f, W); S(18f, 0f, 2f, 2f, W); S(-8f, 12f, 2f, 2f, W);
        S(19f, -4f, 4f, 6f, W); S(16f, -6f, 2f, 2f, W); S(12f, -6f, 2f, 2f, W); S(10f, -7f, 2f, 4f, W); S(6f, -11f, 2f, 4f, W); S(6f, -20f, 2f, 2f, W); S(8f, -18f, 2f, 2f, W); S(0f, 20f, 2f, 2f, W);
        S(4f, -16f, 6f, 2f, W); S(4f, -14f, 2f, 2f, W); S(2f, -12f, 2f, 2f, W); S(-2f, -12f, 2f, 2f, W); S(0f, -14f, 2f, 2f, W); S(4f, -4f, 2f, 2f, W); S(2f, -6f, 2f, 2f, W); S(2f, 24f, 2f, 2f, W);
        S(10f, 4f, 2f, 2f, W); S(6f, 2f, 6f, 2f, W); S(3f, 0f, 8f, 2f, W); S(5f, 6f, 4f, 2f, W); S(23f, 2f, 4f, 2f, W); S(5f, 22f, 4f, 2f, W); S(4f, 12f, 6f, 2f, W); S(18f, 4f, 6f, 6f, W);
        S(12f, 12f, 6f, 6f, W); S(18f, 4f, 2f, 2f, B); S(12f, 12f, 2f, 2f, B); S(2f, 16f, 6f, 2f, W); S(20f, 22f, 6f, 2f, W); S(14f, 24f, 6f, 2f, W); S(-20f, 1f, 2f, 8f, W); S(-24f, -3f, 2f, 8f, W);
        S(-16f, 4f, 2f, 6f, W); S(-8f, 5f, 2f, 4f, W); S(-12f, 6f, 2f, 2f, W); S(-10f, 8f, 2f, 2f, W); S(-14f, 8f, 2f, 2f, W); S(-18f, 7f, 2f, 4f, W); S(-22f, 6f, 2f, 6f, W); S(18f, 18f, 2f, 2f, W);
        S(14f, 18f, 2f, 2f, W); S(14f, 22f, 2f, 2f, W); S(16f, 20f, 2f, 2f, W); S(12f, 20f, 2f, 2f, W); S(8f, 18f, 2f, 2f, W); S(8f, 24f, 2f, 2f, W); S(-12f, -6f, 2f, 2f, W); S(19f, 11f, 4f, 4f, W);
        S(23f, 8f, 4f, 2f, W); S(21f, 14f, 4f, 2f, W); S(-17f, -6f, 4f, 2f, W); S(-9f, -8f, 4f, 2f, W); S(1f, 14f, 4f, 2f, W); S(-15f, 2f, 8f, 2f, W); S(-14f, -2f, 6f, 2f, W); S(-4f, -23f, 2f, 4f, W);
        S(-8f, -23f, 2f, 4f, W); S(-6f, -15f, 2f, 8f, W); S(-6f, -4f, 2f, 6f, W); S(-8f, -4f, 2f, 2f, W); S(-2f, -5f, 2f, 4f, W); S(-4f, -9f, 2f, 4f, W); S(0f, 4f, 2f, 2f, W); S(2f, 8f, 2f, 2f, W);
        S(-6f, 8f, 2f, 2f, W); S(-8f, 0f, 2f, 2f, W); S(0f, -19f, 2f, 4f, W); S(0f, 10f, 14f, 2f, W); S(3f, -21f, 4f, 4f, W); S(-3f, -17f, 4f, 4f, W); S(-2f, -22f, 2f, 2f, W); S(-10f, 4f, 2f, 2f, W);
        S(-14f, 4f, 2f, 2f, W); S(-14f, -4f, 2f, 2f, W); S(-18f, -4f, 2f, 2f, W); S(-22f, -2f, 2f, 2f, W); S(6f, 14f, 2f, 2f, W); S(22f, 20f, 2f, 2f, W); S(-22f, -8f, 2f, 2f, W);
        frame.Draw();
    }
    void S(float P1, float P2, float S1, float S2, Color C)
    {
        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(10 * P1, 10 * P2) * scale + centerPos, new Vector2(10 * S1, 10 * S2) * scale, C, null, TextAlignment.CENTER));
    }
}

public class Button
{
    public Rectangle Hitbox;
    public Action Clicked;
    public Action Hover;
    public Action Click;
    public Button(int x, int y, int w, int h, Action MyAction, Action MyClick = null, Action MyHover = null)
    {
        Hitbox = new Rectangle(x, y, w, h);
        Clicked = MyAction;
        Click = MyClick;
        Hover = MyHover;
    }
    public void OnClick()
    {
        if (Click != null)
            Click();
    }
    public void OnClicked()
    {
        if (Clicked != null)
            Clicked();
    }
    public void OnHover()
    {
        if (Hover != null)
            Hover();
    }
}

public void Debug(Window Window, byte Action)
{
    var frame = Window.SpritesBuilder;
    switch (Action)
    {
        case 0:
            Window.Base = new Rectangle((int)(Window.Screen.TextureSize.X / 2 - (128 * Window.Scale)), (int)(Window.Screen.TextureSize.Y / 2 - (128 * Window.Scale)), (int)(256 * Window.Scale), (int)(256 * Window.Scale));
            Window.MyFrame = Window.Base;
            Window.Configs[1] = 1;
            Window.Configs[5] = "Debug info Version 2.0.3   (c) The Order-All rights reserved";
            break;
        case 1:
            if (frame.Count == 0)
            {
                Window.SpritesBuilder = Window.Content();
                frame = Window.SpritesBuilder;
                float scale = (Window.MyFrame.Width / 512f > Window.MyFrame.Height / 512f) ? (float)Window.MyFrame.Height / 512f : (float)Window.MyFrame.Width / 512f;
                var centerPos = new Vector2I(Window.MyFrame.Center.X, Window.MyFrame.Center.Y);
                var canvas = Window.Meta.CanvasColor;
                var TA = TextAlignment.CENTER;
                string DebugText = $"Time: {DateTime.Now} \n" +
                    $"Screen Resolution: {((Workstation)Window.Configs[0]).ViewPort.Size}\n" +
                    $"Mouse Pos: {((Workstation)Window.Configs[0]).Cursor}\n" +
                    $"Window Size: {{X:{Window.MyFrame.Height} Y:{Window.MyFrame.Height}}}\n" +
                    $"Window Posi: {{X:{Window.MyFrame.X} Y:{Window.MyFrame.Y}}}\n" +
                    $"Frame:{clock / 10}\nScale:{scale}\n" +
                    $"Sprites: {Window.Sprites.Count()}/{((Workstation)Window.Configs[0]).SpriteCount}/{Telemetry.TotalFrameCount}\n" +
                    $"{HWText}";
                {
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(4f, 12f) * scale + centerPos, new Vector2(472f, 410f) * scale, new Color(9, 98, 166, 255), null, TA)); // InfoDisplayPanel
                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(4f, 12f) * scale + (centerPos - (new Vector2(472f, 410f) * scale / 2)), new Vector2(472f, 410f) * scale, new Color(9, 98, 166, 255), null, TextAlignment.LEFT)); // InfoDisplayPanelCanvas
                    frame.Add(new MySprite(SpriteType.TEXT, DebugText, new Vector2(-220f, -147f) * scale + centerPos, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, .9f * scale));
                    frame.Add(new MySprite(SpriteType.TEXT, "      Debug Info:", new Vector2(-128f, -193f) * scale + centerPos, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 1.3f * scale));
                    frame.Add(MySprite.CreateClearClipRect());
                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(Window.MyFrame.X, Window.MyFrame.Y), new Vector2(Window.MyFrame.Width, Window.MyFrame.Height), null, null, TextAlignment.LEFT));
                    frame.Add(new MySprite(SpriteType.TEXT, "Debug Info Display V2.0.1", new Vector2(-88f, -237f) * scale + centerPos, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 1f * scale)); // Title
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(50f, -200f) * scale + centerPos, new Vector2(380f, 5f) * scale, new Color(255, 255, 255, 255), null, TA)); // WhiteLine
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(100f, 100f) * scale, new Color(9, 98, 166, 255), null, TA)); // ThemeCircle
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(90f, 90f) * scale, Window.Meta.CanvasColor, null, TA)); // CircleMask
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(210f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine6
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(150f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine5
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(90f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine4
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(30f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine3
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-30f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine2
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-90f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine1
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(80f, 80f) * scale, new Color(255, 255, 255, 255), null, TA)); // WhiteCircle
                    frame.Add(new MySprite(SpriteType.TEXTURE, Window.Meta.FactionIcon, new Vector2(-183f, -200f) * scale + centerPos, new Vector2(80f, 80f) * scale, Window.Meta.FactionColor, null, TA)); // WhiteCircle
                    foreach (MySprite Sprite in Window.ToolBar()) { frame.Add(Sprite); }
                    foreach (MySprite Sprite in Window.Footer()) { frame.Add(Sprite); }
                }

            }
            break;
        case 2:
            Window.Sprites = frame.ToList();
            Window.SpritesBuilder.Clear();
            break;
        case 3: break;
        case 4: break;
    }
}

public void MathVisualizer(Window Window, byte Action)
{
    var frame = Window.SpritesBuilder;
    switch (Action)
    {
        case 0:
            Window.Base = new Rectangle((int)(Window.Screen.TextureSize.X / 2 - (128 * Window.Scale)), (int)(Window.Screen.TextureSize.Y / 2 - (128 * Window.Scale)), (int)(256 * Window.Scale), (int)(256 * Window.Scale));
            Window.MyFrame = Window.Base;
            Window.Configs[1] = 1;
            Window.Configs[5] = "Math Visualizer Version 0.1   (c) The Order-All rights reserved";
            break;
        case 1:
            if (frame.Count == 0)
            {
                Window.SpritesBuilder = Window.Content();
                frame = Window.SpritesBuilder;
                float scale = (Window.MyFrame.Width / 512f > Window.MyFrame.Height / 512f) ? (float)Window.MyFrame.Height / 512f : (float)Window.MyFrame.Width / 512f;
                var centerPos = new Vector2I(Window.MyFrame.Center.X, Window.MyFrame.Center.Y);
                var canvas = Window.Meta.CanvasColor;
                var TA = TextAlignment.CENTER;
                {
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(4f, 12f) * scale + centerPos, new Vector2(472f, 410f) * scale, new Color(9, 98, 166, 255), null, TA)); // InfoDisplayPanel
                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(4f, 12f) * scale + (centerPos - (new Vector2(472f, 410f) * scale / 2)), new Vector2(472f, 410f) * scale, new Color(9, 98, 166, 255), null, TextAlignment.LEFT)); // InfoDisplayPanelCanvas
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(0, 0) * scale + centerPos, new Vector2(MathInt1, MathInt2) * scale, new Color(255, 255, 255, 255), null, TextAlignment.CENTER, MathHelper.ToRadians(MathInt)));
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareHollow", new Vector2(0, 0) * scale + centerPos,

                        new Vector2(

                        Math.Abs(MathInt1 * (float)Math.Cos(MathHelper.ToRadians(180 - MathInt))) + Math.Abs(MathInt2 * (float)Math.Sin(MathHelper.ToRadians(180 - MathInt))),
                        Math.Abs(MathInt1 * (float)Math.Cos(MathHelper.ToRadians(MathInt - 90))) + Math.Abs(MathInt2 * (float)Math.Cos(MathHelper.ToRadians(180 - MathInt))))*scale

                        ,Color.Yellow, null, TextAlignment.CENTER, 0));

                    frame.Add(new MySprite(SpriteType.TEXT, $"D:{MathInt}ª,R:{MathHelper.ToRadians(MathInt)}\nSin:{Math.Sin(MathHelper.ToRadians(MathInt)):0.00},Cos:{Math.Cos(MathHelper.ToRadians(MathInt)):0.00}\nX:{MathInt1},Y:{MathInt2}", new Vector2(0, 0) * scale + centerPos, null, Color.Red, "DEBUG", TextAlignment.CENTER, 1.3f * scale));



                    frame.Add(MySprite.CreateClearClipRect());
                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(Window.MyFrame.X, Window.MyFrame.Y), new Vector2(Window.MyFrame.Width, Window.MyFrame.Height), null, null, TextAlignment.LEFT));
                    frame.Add(new MySprite(SpriteType.TEXT, "Math Visualizer Version 0.1", new Vector2(-88f, -237f) * scale + centerPos, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 1f * scale)); // Title
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(50f, -200f) * scale + centerPos, new Vector2(380f, 5f) * scale, new Color(255, 255, 255, 255), null, TA)); // WhiteLine
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(100f, 100f) * scale, new Color(9, 98, 166, 255), null, TA)); // ThemeCircle
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(90f, 90f) * scale, Window.Meta.CanvasColor, null, TA)); // CircleMask
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(210f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine6
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(150f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine5
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(90f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine4
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(30f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine3
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-30f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine2
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-90f, -200f) * scale + centerPos, new Vector2(10f, 7f) * scale, Window.Meta.CanvasColor, null, TA)); // MaskLine1
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * scale + centerPos, new Vector2(80f, 80f) * scale, new Color(255, 255, 255, 255), null, TA)); // WhiteCircle
                    frame.Add(new MySprite(SpriteType.TEXTURE, Window.Meta.FactionIcon, new Vector2(-183f, -200f) * scale + centerPos, new Vector2(80f, 80f) * scale, Window.Meta.FactionColor, null, TA)); // WhiteCircle
                    foreach (MySprite Sprite in Window.ToolBar()) { frame.Add(Sprite); }
                    foreach (MySprite Sprite in Window.Footer()) { frame.Add(Sprite); }
                }

            }
            break;
        case 2:
            Window.Sprites = frame.ToList();
            Window.SpritesBuilder.Clear();
            break;
        case 3: break;
        case 4: break;
    }
}

class MediaPlayer
{
    public MediaPlayer()
    { }

    Window Window;
    float Z;
    Vector2I P;
    TextAlignment Ta = TextAlignment.CENTER;
    Color W = Color.White, C, F;

    IMySoundBlock MainSound;

    public void MyMediaPlayer(Window _Window, byte Action)
    {
        Window = _Window;
        var frame = Window.SpritesBuilder;
        switch (Action)
        {
            case 0:
                Window.Base = new Rectangle((int)(Window.Screen.TextureSize.X / 2 - (128 * Window.Scale)), (int)(Window.Screen.TextureSize.Y / 2 - (128 * Window.Scale)), (int)(256 * Window.Scale), (int)(256 * Window.Scale));
                Window.MyFrame = Window.Base;
                C = Window.Meta.CanvasColor; F = Window.Meta.FactionColor;
                Window.Configs[1] = 1;
                Window.Configs[5] = "Media Player Version 0.1   (c) The Order-All rights reserved";
                break;
            case 1:
                if (frame.Count == 0)
                {
                    Z = (Window.MyFrame.Width / 512f > Window.MyFrame.Height / 512f) ? (float)Window.MyFrame.Height / 512f : (float)Window.MyFrame.Width / 512f;
                    P = new Vector2I(Window.MyFrame.Center.X, Window.MyFrame.Center.Y);
                    Window.SpritesBuilder = Window.Content();
                    frame = Window.SpritesBuilder;
                    var canvas = C;
                    var TA = TextAlignment.CENTER;
                    {
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(4f, 12f) * Z + P, new Vector2(472f, 410f) * Z, new Color(9, 98, 166, 255), null, TA));
                        frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(4f, 12f) * Z + (P - (new Vector2(472f, 410f) * Z / 2)), new Vector2(472f, 410f) * Z));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-180f, 170f) * Z + P, new Vector2(50f, 50f) * Z, F, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(180f, 170f) * Z + P, new Vector2(50f, 50f) * Z, F, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(0f, 170f) * Z + P, new Vector2(355f, 50f) * Z, F, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(90f, 170f) * Z + P, new Vector2(10f, 30f) * Z, W, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-90f, 170f) * Z + P, new Vector2(10f, 30f) * Z, W, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Triangle", new Vector2(-60f, 170f) * Z + P, new Vector2(30f, 30f) * Z, W, null, Ta, -1.5708f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Triangle", new Vector2(-80f, 170f) * Z + P, new Vector2(30f, 30f) * Z, W, null, Ta, -1.5708f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Triangle", new Vector2(80f, 170f) * Z + P, new Vector2(30f, 30f) * Z, W, null, Ta, 1.5708f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Triangle", new Vector2(60f, 170f) * Z + P, new Vector2(30f, 30f) * Z, W, null, Ta, 1.5708f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(0f, 170f) * Z + P, new Vector2(80f, 80f) * Z, C, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(0f, 170f) * Z + P, new Vector2(70f, 70f) * Z, F, null, Ta, 0f));
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Triangle", new Vector2(5f, 170f) * Z + P, new Vector2(30f, 30f) * Z, new Color(255, 255, 255, 255), null, Ta, 1.5708f));
                        if (Window.Sound.Count == 0)
                            frame.Add(new MySprite(SpriteType.TEXT, "Warning, no Sound Device Detected", new Vector2(0, 0) * Z + P, null, new Color(255, 255, 255, 255), "DEBUG", Ta, 1f * Z)); // Title
                        else
                        {
                            List<string> Sounds = new List<string>();
                            MainSound = Window.Sound.First();
                            if (MainSound.IsSoundSelected)
                            {
                                frame.Add(new MySprite(SpriteType.TEXT, $"Now Playing: {MainSound.SelectedSound}.xwm", new Vector2(-131f, -190f) * Z + P, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 0.8f * Z)); // Now Playing:
                            }
                            MainSound.GetSounds(Sounds);
                            //frame.Add(new MySprite(SpriteType.TEXT, _Sounds, new Vector2(0, -230) * Z + P, null, new Color(255, 255, 255, 255), "DEBUG", Ta, .5f * Z)); // Title
                            Window.Buttons = new List<Button>();
                            NewButton(-95f, 150f, B1); //Prev
                            NewButton(45f, 150f, B2); //Next
                            NewButton(0f, 150f, B3); //PlayPause
                        }

                        frame.Add(MySprite.CreateClearClipRect());
                        frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", new Vector2(Window.MyFrame.X, Window.MyFrame.Y), new Vector2(Window.MyFrame.Width, Window.MyFrame.Height), null, null, TextAlignment.LEFT));
                        frame.Add(new MySprite(SpriteType.TEXT, "Media Player Version 0.1", new Vector2(-88f, -237f) * Z + P, null, new Color(255, 255, 255, 255), "DEBUG", TextAlignment.LEFT, 1f * Z)); // Title
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(50f, -200f) * Z + P, new Vector2(380f, 5f) * Z, new Color(255, 255, 255, 255), null, TA)); // WhiteLine
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * Z + P, new Vector2(100f, 100f) * Z, new Color(9, 98, 166, 255), null, TA)); // ThemeCircle
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * Z + P, new Vector2(90f, 90f) * Z, C, null, TA)); // CircleMask
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(210f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine6
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(150f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine5
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(90f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine4
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(30f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine3
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-30f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine2
                        frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(-90f, -200f) * Z + P, new Vector2(10f, 7f) * Z, C, null, TA)); // MaskLine1
                        frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-183f, -200f) * Z + P, new Vector2(80f, 80f) * Z, new Color(255, 255, 255, 255), null, TA)); // WhiteCircle
                        frame.Add(new MySprite(SpriteType.TEXTURE, Window.Meta.FactionIcon, new Vector2(-183f, -200f) * Z + P, new Vector2(80f, 80f) * Z, Window.Meta.FactionColor, null, TA)); // WhiteCircle
                        foreach (MySprite Sprite in Window.ToolBar()) { frame.Add(Sprite); }
                        foreach (MySprite Sprite in Window.Footer()) { frame.Add(Sprite); }
                    }

                }
                break;
            case 2:
                Window.Sprites = frame.ToList();
                Window.SpritesBuilder.Clear();
                break;
            case 3: break;
            case 4: break;
        }
    }
    public void B1() { Window.Configs[15] = (int)Window.Configs[15] + 1; }
    public void B2() { Window.Configs[15] = (int)Window.Configs[15] - 1; }
    public void B3() {
        foreach (IMySoundBlock Sound in Window.Sound) {
            Sound.SelectedSound = MainSound.SelectedSound;
            Sound.Play();
        }
    }

    public void NewButton(float X, float Y, Action ButtonAction)
    {
        Vector2 ButtonPos = (new Vector2(X, Y) * Z) + P - new Vector2(25, 12.5f) * Z;
        Window.Buttons.Add(new Button((int)ButtonPos.X, (int)ButtonPos.Y, (int)(50f * Z), (int)(50f * Z), ButtonAction));
    }

}


public interface ISpriteSurface
{
    Vector2 TextureSize { get; }
    Vector2 SurfaceSize { get; }
    Color ScriptBackgroundColor { get; set; }
    int SpriteCount { get; }
    void Add(MySprite sprite);
    void Draw();
    Vector2 MeasureStringInPixels(StringBuilder text, string font, float scale);
}

public class SingleScreenSpriteSurface : ISpriteSurface
{
    public bool IsValid
    {
        get
        {
            return Surface != null;
        }
    }

    public Vector2 TextureSize { get { return IsValid ? Surface.TextureSize : Vector2.Zero; } }
    public Vector2 SurfaceSize { get { return IsValid ? Surface.SurfaceSize : Vector2.Zero; } }
    public Color ScriptBackgroundColor
    {
        get { return IsValid ? Surface.ScriptBackgroundColor : Color.Black; }
        set { if (IsValid) { Surface.ScriptBackgroundColor = value; } }
    }
    public int SpriteCount { get; private set; } = 0;
    public Vector2 MeasureStringInPixels(StringBuilder text, string font, float scale)
    {
        return IsValid ? Surface.MeasureStringInPixels(text, font, scale) : Vector2.Zero;
    }

    public readonly IMyCubeBlock CubeBlock;
    public readonly IMyTextSurface Surface;
    public MySpriteDrawFrame? Frame = null;
    readonly List<MySprite> _sprites = new List<MySprite>(64);

    public void Add(MySprite sprite)
    {
        if (!IsValid)
        {
            return;
        }
        if (Frame == null)
        {
            Frame = Surface.DrawFrame();
        }
        Frame.Value.Add(sprite);
        SpriteCount++;
    }

    public void Draw()
    {
        Draw(Surface.ScriptBackgroundColor);
        SpriteCount = 0;
    }

    public void Draw(Color scriptBackgroundColor)
    {
        if (!IsValid)
        {
            return;
        }
        Surface.ContentType = ContentType.SCRIPT;
        Surface.Script = "";
        Surface.ScriptBackgroundColor = scriptBackgroundColor;
        if (Frame == null)
        {
            Surface.DrawFrame().Dispose();
        }
        else
        {
            Frame.Value.Dispose();
            Frame = null;
        }
    }

    public SingleScreenSpriteSurface(IMyTextSurface surf)
    {
        Surface = surf;
    }

    public SingleScreenSpriteSurface(IMyCubeGrid grid, Vector3I position)
    {
        var slim = grid.GetCubeBlock(position);
        if (slim != null && slim.FatBlock != null)
        {
            CubeBlock = slim.FatBlock;
            var surf = CubeBlock as IMyTextSurface;
            if (surf != null)
            {
                Surface = surf;
            }
        }
    }
}

// Assumes that all text panels are the same size
public class MultiScreenSpriteSurface : ISpriteSurface
{
    public bool Initialized { get; private set; } = false;

    float Rotation
    {
        get
        {
            return _rotationAngle;
        }
        set
        {
            _rotationAngle = value;
            _spanVectorAbs = RotateToDisplayOrientation(new Vector2(Cols, Rows), RotationRads);
            _spanVectorAbs *= Vector2.SignNonZero(_spanVectorAbs);
        }
    }
    float RotationRads
    {
        get
        {
            return MathHelper.ToRadians(Rotation);
        }
    }
    public Vector2 TextureSize
    {
        get
        {
            if (!_textureSize.HasValue)
            {
                _textureSize = BasePanelSize * _spanVectorAbs;
            }
            return _textureSize.Value;
        }
    }
    public Vector2 SurfaceSize
    {
        get { return TextureSize; }
    }
    public int SpriteCount { get; private set; } = 0;
    public Vector2 MeasureStringInPixels(StringBuilder text, string font, float scale)
    {
        return _anchor.MeasureStringInPixels(text, font, scale);
    }
    public Vector2 BasePanelSize
    {
        get { return _anchor.TextureSize; }
    }
    Vector2 BasePanelSizeNoRotation
    {
        get
        {
            if (!_basePanelSizeNoRotation.HasValue)
            {
                Vector2 size = RotateToBaseOrientation(BasePanelSize, RotationRads);
                size *= Vector2.SignNonZero(size);
                _basePanelSizeNoRotation = size;
            }
            return _basePanelSizeNoRotation.Value;
        }
    }
    Vector2 TextureSizeNoRotation
    {
        get
        {
            if (!_textureSizeNoRotation.HasValue)
            {
                _textureSizeNoRotation = BasePanelSizeNoRotation * new Vector2(Cols, Rows);
            }
            return _textureSizeNoRotation.Value;
        }
    }
    public readonly int Rows;
    public readonly int Cols;

    public Color ScriptBackgroundColor { get; set; } = new MetaData().BackgroundColor;
    StringBuilder _stringBuilder = new StringBuilder(128);
    public IMyTextPanel _anchor;
    ITerminalProperty<float> _rotationProp;
    float _rotationAngle = 0f;
    Vector2? _textureSize;
    Vector2? _basePanelSizeNoRotation;
    Vector2? _textureSizeNoRotation;
    Vector2 _spanVectorAbs;

    readonly SingleScreenSpriteSurface[,] _surfaces;
    readonly Vector2[,] _screenOrigins;
    MyIni _ini = new MyIni();
    public MultiScreenSpriteSurface(IMyTextPanel anchor)
    {
        MyIniParseResult result;
        Rows = 1;
        Cols = 1;
        if (_ini.TryParse(anchor.CustomData, out result))
        {
            if (_ini.ContainsSection("TOS"))
            {
                if (_ini.ContainsKey("TOS", "Rows")) { Rows = int.Parse(_ini.Get("TOS", "Rows").ToString()); } else { _ini.Set("TOS", "Rows", "1"); anchor.CustomData = _ini.ToString(); }
                if (_ini.ContainsKey("TOS", "Cols")) { Cols = int.Parse(_ini.Get("TOS", "Cols").ToString()); } else { _ini.Set("TOS", "Cols", "1"); anchor.CustomData = _ini.ToString(); }
            }
            else { anchor.CustomData += "[TOS]\nRows = 1\nCols = 1"; }
        }
        else { anchor.CustomData += "[TOS]\nRows = 1\nCols = 1"; }
        _anchor = anchor;
        _surfaces = new SingleScreenSpriteSurface[Rows, Cols];
        _screenOrigins = new Vector2[Rows, Cols];

        _rotationProp = anchor.GetProperty("Rotate").Cast<float>();
        Rotation = _rotationProp.GetValue(anchor);

        Vector3I anchorPos = anchor.Position;
        Vector3I anchorRight = -Base6Directions.GetIntVector(anchor.Orientation.Left);
        Vector3I anchorDown = -Base6Directions.GetIntVector(anchor.Orientation.Up);
        Vector3I anchorBlockSize = anchor.Max - anchor.Min + Vector3I.One;
        Vector3I stepRight = Math.Abs(Vector3I.Dot(anchorBlockSize, anchorRight)) * anchorRight;
        Vector3I stepDown = Math.Abs(Vector3I.Dot(anchorBlockSize, anchorDown)) * anchorDown;
        IMyCubeGrid grid = anchor.CubeGrid;
        for (int r = 0; r < Rows; ++r)
        {
            for (int c = 0; c < Cols; ++c)
            {
                Vector3I blockPosition = anchorPos + r * stepDown + c * stepRight;
                var surf = new SingleScreenSpriteSurface(grid, blockPosition);
                _surfaces[r, c] = surf;
                if (surf.CubeBlock != null)
                {
                    _rotationProp.SetValue(surf.CubeBlock, Rotation);
                }

                // Calc screen coords
                Vector2 screenCenter = BasePanelSizeNoRotation * new Vector2(c + 0.5f, r + 0.5f);
                Vector2 fromCenter = screenCenter - 0.5f * TextureSizeNoRotation;
                Vector2 fromCenterRotated = RotateToDisplayOrientation(fromCenter, RotationRads);
                Vector2 screenCenterRotated = fromCenterRotated + 0.5f * TextureSize;
                _screenOrigins[r, c] = screenCenterRotated - 0.5f * BasePanelSize;
            }
        }
    }

    Vector2 RotateToDisplayOrientation(Vector2 vec, float angleRad)
    {
        int caseIdx = (int)Math.Round(angleRad / MathHelper.ToRadians(90));
        switch (caseIdx)
        {
            default:
            case 0:
                return vec;
            case 1: // 90 deg
                return new Vector2(vec.Y, -vec.X);
            case 2: // 180 deg
                return -vec;
            case 3: // 270 deg
                return new Vector2(-vec.Y, vec.X);
        }
    }

    Vector2 RotateToBaseOrientation(Vector2 vec, float angleRad)
    {
        int caseIdx = (int)Math.Round(angleRad / MathHelper.ToRadians(90));
        switch (caseIdx)
        {
            default:
            case 0:
                return vec;
            case 1: // 90 deg
                return new Vector2(-vec.Y, vec.X);
            case 2: // 180 deg
                return -vec;
            case 3: // 270 deg
                return new Vector2(vec.Y, -vec.X);
        }
    }

    public void Add(MySprite sprite)
    {
        Vector2 pos = sprite.Position ?? TextureSize * 0.5f;
        Vector2 spriteSize;
        if (sprite.Size != null && sprite.Type == SpriteType.TEXTURE)
        {
            spriteSize = sprite.Size.Value;
                switch (sprite.Alignment)
                {
                    case TextAlignment.LEFT:
                    sprite.Position = (sprite.Position.Value + new Vector2(sprite.Size.Value.X, 0) / 2);
                    sprite.Alignment = TextAlignment.CENTER;
                    break;

                    case TextAlignment.RIGHT:
                    sprite.Position = (sprite.Position.Value - new Vector2(sprite.Size.Value.X,0) / 2);
                    sprite.Alignment = TextAlignment.CENTER;
                    break;
                }
                pos = sprite.Position ?? TextureSize * 0.5f;
        }
        else
        {
            spriteSize = TextureSize;
        }
        float rad = spriteSize.Length() * 0.5f;


        Vector2 fromCenter = pos - (TextureSize * 0.5f);
        Vector2 fromCenterRotated = RotateToBaseOrientation(fromCenter, RotationRads);
        Vector2 basePos = TextureSizeNoRotation * 0.5f + fromCenterRotated;

        var lowerCoords = Vector2I.Floor((basePos - rad) / BasePanelSizeNoRotation);
        var upperCoords = Vector2I.Floor((basePos + rad) / BasePanelSizeNoRotation);

        int lowerCol = Math.Max(0, lowerCoords.X);
        int upperCol = Math.Min(Cols - 1, upperCoords.X);

        int lowerRow = Math.Max(0, lowerCoords.Y);
        int upperRow = Math.Min(Rows - 1, upperCoords.Y);

        if (sprite.Type == SpriteType.CLIP_RECT || sprite.Size == null)
        {
            for (int r = 0; r < Rows; ++r)
            {
                for (int c = 0; c < Cols; ++c)
                {
                    sprite.Position = pos - _screenOrigins[r, c];
                    _surfaces[r, c].Add(sprite);
                    SpriteCount++;
                }
            }
        }
        else
            for (int r = lowerRow; r <= upperRow; ++r)
            {
                for (int c = lowerCol; c <= upperCol; ++c)
                {
                    sprite.Position = pos - _screenOrigins[r, c];
                    _surfaces[r, c].Add(sprite);
                    SpriteCount++;
                }
            }
    }
    public void Draw()
    {
        for (int r = 0; r < Rows; ++r)
        {
            for (int c = 0; c < Cols; ++c)
            {
                _surfaces[r, c].Draw(ScriptBackgroundColor);
            }
        }
        SpriteCount = 0;
    }
}


class DiagInterface
{
    List<IMyTerminalBlock> Blocks;
    IMyCubeGrid Grid;
    public DiagInterface(List<IMyTerminalBlock> _Blocks, IMyCubeGrid _Grid)
    {
        Blocks = _Blocks; Grid = _Grid;
    }

    public List<string> Dictionary = new List<string> { "00-HUL(indiferente esse n aparece)", "01-HPS", "02-BUK", "03-GRV", "04-LSS", "05-EPS", "06-BTP", "07-PDS", "08-ORS", "09-STT", "10-CDP", "11-STG", "12-H2S", "13-GYR", "14-HTS", "15-ITS", "16-ATS", "17-JPD", "18-WEP", "19-SSR", "20-COM", "21-ILT", "22-EXT", "TOGGLE", "OVRRD" };
    List<MySprite> frame;
    int Page = 1, rotation = 0;
    List<bool> SubSystem;
    Window Window;
    float zoom = 2f, rotationF = 0, Z;
    Vector2I P;
    TextAlignment Ta = TextAlignment.CENTER;
    Color R = Color.Red, G = Color.Green, W = Color.White, D = Color.DarkGray, C, T;
    public void MyDiagInterface(Window _Window, byte Action)
    {
        Window = _Window;
        frame = Window.SpritesBuilder;
        SubSystem = (List<bool>)Window.Configs[15];
        switch (Action)
        {
            case 0:
                Window.Base = new Rectangle((int)(Window.Screen.TextureSize.X / 2 - (192 * Window.Scale)), (int)(Window.Screen.TextureSize.Y / 2 - (128 * Window.Scale)), (int)(384 * Window.Scale), (int)(256 * Window.Scale));
                Window.MyFrame = Window.Base;
                Window.Configs[1] = 2;
                Window.Configs[4] = $"Ship diagnostic, Displaying: {Grid.CustomName}";
                Window.Configs[5] = "Ship diagnostic info Display Version 3.0.6                (c) The Order-All rights reserved";

                C = Window.Meta.CanvasColor; T = Window.Meta.Theme;
                if (Window.Configs[10] == null)
                {
                    Window.Configs[10] = new Diagnostic(Blocks, Grid);
                    Window.Configs[14] = 0; //Angle
                    Window.Configs[15] = new List<bool> { true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false };
                }
                ((Diagnostic)Window.Configs[10]).Update(Window);
                break;
            case 1:
                if (frame.Count == 0)
                {
                    rotationF = MathHelper.ToRadians(rotation);
                    Z = (Window.MyFrame.Width / 512f > Window.MyFrame.Height / 512f) ? (float)Window.MyFrame.Height / 512f : (float)Window.MyFrame.Width / 512f;
                    P = new Vector2I(Window.MyFrame.Center.X, Window.MyFrame.Center.Y);
                    Window.SpritesBuilder = Window.Content();
                    frame = Window.SpritesBuilder;

                    TD("Ship diagnostic info Display V 3.0.1", 0 - 251f, -237f, W, 1f, Z, P); // Title
                    SS(-50f, -200f, 500f, 5f, W, Z, P); // WhiteLine
                    SS(-40f, -4f, 660f, 380f, T, Z, P); // InfoDisplayPanel
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-320f, -200f) * Z + P, new Vector2(100f, 100f) * Z, T, null, Ta)); // ThemeCircle
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-320f, -200f) * Z + P, new Vector2(90f, 90f) * Z, C, null, Ta)); // CircleMask
                    SS(195f, -200f, 10f, 7f, C, Z, P); // MaskLine10
                    SS(145f, -200f, 10f, 7f, C, Z, P); // MaskLine9
                    SS(95f, -200f, 10f, 7f, C, Z, P); // MaskLine8
                    SS(45f, -200f, 10f, 7f, C, Z, P); // MaskLine7
                    SS(-5f, -200f, 10f, 7f, C, Z, P); // MaskLine6
                    SS(-55f, -200f, 10f, 7f, C, Z, P); // MaskLine5
                    SS(-105f, -200f, 10f, 7f, C, Z, P); // MaskLine4
                    SS(-155f, -200f, 10f, 7f, C, Z, P); // MaskLine3
                    SS(-205f, -200f, 10f, 7f, C, Z, P); // MaskLine2
                    SS(-255f, -200f, 10f, 7f, C, Z, P); // MaskLine1
                    NewButton(340f, 170f, BV2);// View-Button
                    NewButton(340f, 135f, BRS);// Rotate-Button
                    NewButton(340f, 105f, BRP);// Rotate+Button
                    NewButton(340f, 70f, BV1); // View+Button
                    NewButton(340f, 20f, BP);  // PrevButton
                    NewButton(340f, -20f, B4); // Act4Button
                    NewButton(340f, -60f, B3); // Act3Button
                    NewButton(340f, -100f, B2);// Act2Button
                    NewButton(340f, -140f, B1);// Act1Button
                    NewButton(340f, -180f, BN);// NextButton
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Arrow", new Vector2(340f, 70f) * Z + P, new Vector2(20f, 20f) * Z, new Color(0, 0, 0, 255), null, Ta)); // View+
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Arrow", new Vector2(340f, 105f) * Z + P, new Vector2(20f, 20f) * Z, new Color(0, 0, 0, 255), null, Ta, 1.5708f)); // Rotate+
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Arrow", new Vector2(340f, 135f) * Z + P, new Vector2(20f, 20f) * Z, new Color(0, 0, 0, 255), null, Ta, -1.5708f)); // Rotate-
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Arrow", new Vector2(340f, 170f) * Z + P, new Vector2(20f, 20f) * Z, new Color(0, 0, 0, 255), null, Ta, 3.1416f)); // View-
                    TM("PREV", 342f, 15f, new Color(0, 0, 0, 255), 0.4f, Z, P); // PreviousButtonN
                    TM(Dictionary[Page], 342f, -145f, new Color(0, 0, 0, 255), 0.4f, Z, P); // Button1N
                    TM(Dictionary[Page + 1], 342f, -105f, new Color(0, 0, 0, 255), 0.4f, Z, P); // Button2N
                    TM(Dictionary[Page + 2], 342f, -65f, new Color(0, 0, 0, 255), 0.4f, Z, P); // Button3N
                    TM(Dictionary[Page + 3], 342f, -25f, new Color(0, 0, 0, 255), 0.4f, Z, P); // Button4N
                    TM("NEXT", 342f, -185f, new Color(0, 0, 0, 255), 0.4f, Z, P); // NextButtonN
                    SS(360f, -28f, 5f, 5f, (SubSystem[Page + 3]) ? G : R, Z, P); // L4
                    SS(360f, -68f, 5f, 5f, (SubSystem[Page + 2]) ? G : R, Z, P); // L3
                    SS(360f, -108f, 5f, 5f, (SubSystem[Page + 1]) ? G : R, Z, P); // L2
                    SS(360f, -148f, 5f, 5f, (SubSystem[Page]) ? G : R, Z, P); // L1
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Circle", new Vector2(-320f, -200f) * Z + P, new Vector2(80f, 80f) * Z, W, null, Ta)); // FactionIconBack
                    frame.Add(new MySprite(SpriteType.TEXTURE, Window.Meta.FactionIcon, new Vector2(-320f, -200f) * Z + P, new Vector2(80f, 80f) * Z, Window.Meta.FactionColor, null, Ta)); // TheOrderLogo
                    var size = new Vector2(640f, 320f) * Z;
                    RectangleF DrawArea = new RectangleF(new Vector2(-40f, 10f) * Z + P - size / 2, size);
                    frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", DrawArea.Position + new Vector2(0, DrawArea.Size.Y / 2), DrawArea.Size, new Color(0, 0, 0, 255), null, TextAlignment.LEFT)); // InfoDisplayBlack
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Grid", DrawArea.Position + new Vector2(0, DrawArea.Size.Y / 2), new Vector2(DrawArea.Size.Y, DrawArea.Size.Y), W, null, TextAlignment.LEFT)); // InfoDisplayBlack
                    frame.Add(new MySprite(SpriteType.TEXTURE, "Grid", DrawArea.Position + new Vector2(DrawArea.Size.Y, DrawArea.Size.Y / 2), new Vector2(DrawArea.Size.Y, DrawArea.Size.Y), W, null, TextAlignment.LEFT)); // InfoDisplayBlack
                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", DrawArea.Position, DrawArea.Size, null, null, TextAlignment.LEFT)); // InfoDisplayBack
                    foreach (MySprite S in ((Diagnostic)Window.Configs[10]).Get(Window))
                    {
                        float sin = (float)Math.Sin(rotationF);
                        float cos = (float)Math.Cos(rotationF);
                        frame.Add(new MySprite(S.Type, S.Data, (S.Type == SpriteType.TEXT) ? S.Position * Z + DrawArea.Center : new Vector2(cos * S.Position.Value.X - sin * S.Position.Value.Y, sin * S.Position.Value.X + cos * S.Position.Value.Y) * (Z * zoom) + DrawArea.Center, (S.Size != null) ? S.Size * (Z * zoom) : null, S.Color, S.FontId, S.Alignment, (S.Type == SpriteType.TEXT) ? S.RotationOrScale * Z : rotationF));
                    }
                    SmallButton(260f, 120f, BZS);
                    SmallButton(260f, 150f, BZP);

                    if (rotation != 0 && zoom > 1) frame.Add(new MySprite(SpriteType.TEXT, "Due to screens limitations\nrotate a image larger than\ncanvas cause visual glitch\nCheck: Shorturl.at/vCR89", new Vector2(40f, -140f) * Z + P, null, Color.Red, "Monospace", TextAlignment.LEFT, .4f * Z)); // ShipName

                    frame.Add(new MySprite(SpriteType.CLIP_RECT, "SquareSimple", (new Vector2(15f - 260f, -170f - 15f)) * Z + P, new Vector2(520f, 30f) * Z, null, null, TextAlignment.LEFT)); //NameCLIP_RECT
                    SS(15f, -170f, 530f, 30f, W, Z, P); // Name Frame
                    frame.Add(new MySprite(SpriteType.TEXT, Grid.CustomName, new Vector2(-243f, -187f) * Z + P, null, T, "DEBUG", TextAlignment.LEFT, 1f * Z)); // ShipName
                    frame.Add(MySprite.CreateClearClipRect());

                    foreach (MySprite Sprite in Window.ToolBar()) { frame.Add(Sprite); }
                    foreach (MySprite Sprite in Window.Footer()) { frame.Add(Sprite); }
                }
                break;
            case 2:
                Window.Sprites = frame.ToList();
                Window.SpritesBuilder.Clear();
                break;
        }
    }
    public void NewButton(float X, float Y, Action ButtonAction)
    {
        Vector2 ButtonPos = (new Vector2(X, Y) * Z) + P - new Vector2(25, 12.5f) * Z;
        SL(ButtonPos.X, ButtonPos.Y + 12.5f * Z, 50f, 25f, W, Z, P); // PrevButton
        Window.Buttons.Add(new Button((int)ButtonPos.X, (int)ButtonPos.Y, (int)(50f * Z), (int)(25f * Z), ButtonAction));
        frame.Add(new MySprite(SpriteType.TEXTURE, "RightTriangle", new Vector2(X - 20, Y - 7.5f) * Z + P, new Vector2(10f, 10f) * Z, D, null, Ta, 1.5708f));
    }
    public void SmallButton(float X, float Y, Action ButtonAction)
    {
        Vector2 ButtonPos = (new Vector2(X, Y) * Z) + P - new Vector2(12.5f, 12.5f) * Z;
        SL(ButtonPos.X, ButtonPos.Y + 12.5f * Z, 25, 25, W, Z, P); // PrevButton
        Window.Buttons.Add(new Button((int)ButtonPos.X, (int)ButtonPos.Y, (int)(50f * Z), (int)(25f * Z), ButtonAction));
    }

    public void SS(float P1, float P2, float S1, float S2, Color C, float S, Vector2 P)
    { frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(P1, P2) * S + P, new Vector2(S1, S2) * S, C, null, TextAlignment.CENTER)); }
    public void SL(float P1, float P2, float S1, float S2, Color C, float S, Vector2 P)
    { frame.Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(P1, P2), new Vector2(S1, S2) * S, C, null, TextAlignment.LEFT)); }

    public void TD(string text, float P1, float P2, Color C, float S, float s, Vector2 P)
    { frame.Add(new MySprite(SpriteType.TEXT, text, new Vector2(P1, P2) * s + P, null, C, "DEBUG", TextAlignment.LEFT, s * S)); }
    public void TM(string text, float P1, float P2, Color C, float S, float s, Vector2 P)
    { frame.Add(new MySprite(SpriteType.TEXT, text, new Vector2(P1, P2) * s + P, null, C, "Monospace", TextAlignment.CENTER, s * S)); }

    public void CH(float P1, float P2, Color C, float R, float S, Vector2 P)
    {
        frame.Add(new MySprite(SpriteType.TEXTURE, "RightTriangle", new Vector2(P1, P2) * S + P, new Vector2(10f, 10f) * S, C, null, TextAlignment.CENTER, R)); // NextButtonCh
    }

    public void B1() { ((List<bool>)Window.Configs[15])[Page] = !SubSystem[Page]; }
    public void B2() { ((List<bool>)Window.Configs[15])[Page + 1] = !SubSystem[Page + 1]; }
    public void B3() { ((List<bool>)Window.Configs[15])[Page + 2] = !SubSystem[Page + 2]; }
    public void B4() { ((List<bool>)Window.Configs[15])[Page + 3] = !SubSystem[Page + 3]; }
    public void BN() { Page += 4; if (Page > 21) Page = 1; }
    public void BP() { Page -= 4; if (Page < 1) Page = 21; }
    public void BV1()
    {
        int I = (int)Window.Configs[14];
        switch (I)
        {
            case 2: I = 0; break;
            case 1: I = 2; break;
            case 3: I = 1; break;
            case 0: I = 3; break;
        }
        Window.Configs[14] = I;
    }
    public void BV2()
    {
        int I = (int)Window.Configs[14];
        switch (I)
        {
            case 0: I = 2; break;
            case 2: I = 1; break;
            case 1: I = 3; break;
            case 3: I = 0; break;
        }
        Window.Configs[14] = I;
    }
    public void BRP() { rotation += 15; if (rotation > 345) rotation = 0; }
    public void BRS() { rotation -= 15; if (rotation < 0) rotation = 345; }
    public void BZP() { zoom += .4f; if (zoom > 10f) zoom = 10f; }
    public void BZS() { zoom -= .4f; if (zoom < .6f) zoom = .6f; }
}

public class SpriteListData
{
    public List<MySprite> Sprites { get; set; }
    public DateTime Time { get; set; }
    public SpriteListData(List<MySprite> _Sprites)
    {
        Sprites = _Sprites;
        Time = DateTime.Now;
    }
}
public class Diagnostic
{
    readonly List<List<SpriteListData>> LoL;
    ShipDiagnostic MyShipDiagnostic;
    List<MySprite> SpriteList = new List<MySprite>();
    List<IMyTerminalBlock> Blocks, Sensors;
    int? Current;
    IEnumerator<bool> Task;
    IEnumerator<bool> Clear;
    public Diagnostic() { }
    public Diagnostic(List<IMyTerminalBlock> _Blocks, IMyCubeGrid Grid)
    {
        MyShipDiagnostic = new ShipDiagnostic(Grid);
        Blocks = _Blocks;
        LoL = new List<List<SpriteListData>>(new List<SpriteListData>[23]);
        for (int i = 0; i < LoL.Count(); ++i)
        {
            LoL[i] = new List<SpriteListData>(new SpriteListData[6]);
        }
        foreach (IMyTerminalBlock Block in Blocks) { if (Sensors == null) Sensors = new List<IMyTerminalBlock>(); if (Block is IMySensorBlock|| Block is IMyTurretControlBlock || Block is IMyLargeTurretBase) Sensors.Add(Block); }
    }
    public List<MySprite> Get(Window Window)
    {
        int I = (int)Window.Configs[14];
        SpriteList = new List<MySprite>();
        if (LoL[0] != null)
        {
            if (LoL[0][I] != null)
            {
                if (LoL[0][I].Sprites != null)
                {
                    SpriteList = LoL[0][I].Sprites.ToList();
                    for (int i = 1; i < LoL.Count(); ++i)
                    {
                        if (LoL[i][I] != null && ((List<bool>)Window.Configs[15])[i]) foreach (MySprite Sprite in LoL[i][I].Sprites) SpriteList.Add(Sprite);
                    }
                    if (Sensors.Count > 0)
                        foreach (MySprite Sprite in MyShipDiagnostic.Sensor(I, Sensors)) SpriteList.Add(Sprite);
                    SpriteList.Add(new MySprite(SpriteType.TEXT, $"Last Update: {new TimeAgo(LoL[0][I].Time).Time}", new Vector2(0, 140f), null, Color.White, "Monospace", TextAlignment.CENTER, .4f));
                }
                else
                {
                    Update(Window);
                }
                if (DateTime.Now.Ticks > LoL[0][I].Time.Ticks + 3000000000)
                {
                    Update(Window);
                }
            }
            else
            {
                Update(Window);
            }
        }
        else
        {
            Update(Window);
        }
        return SpriteList;
    }
    public void Update(Window Window)
    {
        if (Task == null)
        {
            Current = (int)Window.Configs[14];
            MyShipDiagnostic.Stat = 0;
        }
        if (Clear == null)
            Clear = MyShipDiagnostic.ClearDiag(Blocks).GetEnumerator();
        if (Clear.MoveNext() == false)
        {
            if (Task == null)
                Task = MyShipDiagnostic.RunDiag(Current.Value).GetEnumerator();
            if (Task.MoveNext() == false)
            {
                Task.Dispose();
                Task = null;
                for (int i = 0; i < LoL.Count(); ++i)
                {
                    if (MyShipDiagnostic.Sprites[i] != null) { LoL[i][Current.Value] = new SpriteListData(MyShipDiagnostic.Sprites[i].ToList()); }
                }
                Current = null;
            }
        }
        SpriteList.Add(new MySprite(SpriteType.TEXT, $"Loading...\n{MyShipDiagnostic.Stat}/5", new Vector2(0, 0), null, Color.White, "Monospace", TextAlignment.CENTER, 1f)); // Title);

    }
}


public class ShipDiagnostic
{
    List<IMyTerminalBlock> Blocks = new List<IMyTerminalBlock> { };
    public IMyCubeGrid Grid { get; set; }
    public BlockState[,,] Saved_Grid { get; set; }
    public Vector3I Grid_Min { get; set; }
    public Vector3I Grid_Max { get; set; }
    public List<TerminalBlockState> TerminalBlocks { get; set; }
    public TileState[,] Tiles;
    public int DiagHull, tilesize, Stat;
    public Window Me { get; set; }
    public int Angle { get; set; }
    public int Plane { get; set; }
    public string DiagStatus { get; set; }
    public List<List<MySprite>> Sprites { get; set; }
    public IEnumerator<bool> ResetDiag { get; set; }
    public IEnumerator<bool> DiagTask { get; set; }
    public ShipDiagnostic(IMyCubeGrid _Grid)
    {
        Grid = _Grid;
        TerminalBlocks = new List<TerminalBlockState>();
    }
    public delegate Vector3I Rotation(Vector3I pos, Vector3I size);
    public enum BlockState { Empty, Missing, Damaged, Normal }
    public struct TileState { public int Healthy, Total; public int Depth; }
    public struct TerminalBlockState
    {
        public Vector3I Position, Size;
        public BlockState State;
        public IMyTerminalBlock Block;
    }

    static Vector3I X_P(Vector3I pos, Vector3I size) { return new Vector3I(pos.Z, pos.Y, pos.X); }
    static Vector3I Y_P(Vector3I pos, Vector3I size) { return new Vector3I(size.Z - pos.Z, pos.X, pos.Y); }
    static Vector3I Z_P(Vector3I pos, Vector3I size) { return new Vector3I(size.X - pos.X, pos.Y, pos.Z); }
    static Vector3I X_N(Vector3I pos, Vector3I size) { return new Vector3I(pos.Z, size.Y - pos.Y, size.X - pos.X); }
    static Vector3I Y_N(Vector3I pos, Vector3I size) { return new Vector3I(size.Z - pos.Z, size.X - pos.X, size.Y - pos.Y); }
    static Vector3I Z_N(Vector3I pos, Vector3I size) { return new Vector3I(size.X - pos.X, size.Y - pos.Y, size.Z - pos.Z); }
    static Rotation[] Bit = new Rotation[] { X_N, X_P, Y_N, Y_P, Z_N, Z_P, };

    public IEnumerable<bool> ClearDiag(List<IMyTerminalBlock> _Blocks)
    {
        Blocks = _Blocks;
        foreach (bool val in CheckGrid(false))
            yield return val;
        TerminalBlocks.Clear();
        for (int i = 0; i < Blocks.Count; ++i)
            if (Blocks[i].IsFunctional && Blocks[i].CubeGrid == Grid)
                TerminalBlocks.Add(new TerminalBlockState { Position = Blocks[i].Min, Size = Blocks[i].Max - Blocks[i].Min + Vector3I.One, State = BlockState.Normal, Block = Blocks[i] });
        yield break;
    }

    IEnumerable<bool> CheckGrid(bool check_damaged)
    {
        if (check_damaged == false)
        {
            Grid_Min = Grid.Min - Vector3I.One;
            Grid_Max = Grid.Max + Vector3I.One;
            Saved_Grid = new BlockState[Grid_Max.X - Grid_Min.X, Grid_Max.Y - Grid_Min.Y, Grid_Max.Z - Grid_Min.Z];
            tilesize = Math.Max(Grid_Max.X - Grid_Min.X, Math.Max(Grid_Max.Y - Grid_Min.Y, Grid_Max.Z - Grid_Min.Z)) + 1;
            Tiles = new TileState[tilesize, tilesize];
        }
        int total_healthy = 0, total = 0;
        for (int _X = Grid_Min.X; _X < Grid_Max.X; ++_X)
        {
            for (int y = Grid_Min.Y; y < Grid_Max.Y; ++y)
            {
                for (int z = Grid_Min.Z; z < Grid_Max.Z; ++z)
                {
                    Vector3I pos = new Vector3I(_X, y, z);
                    if (check_damaged)
                    {
                        if (Saved_Grid[_X - Grid_Min.X, y - Grid_Min.Y, z - Grid_Min.Z] != BlockState.Empty)
                        {
                            ++total;
                            if (!Grid.CubeExists(pos))
                                Saved_Grid[_X - Grid_Min.X, y - Grid_Min.Y, z - Grid_Min.Z] = BlockState.Missing;
                            else
                                ++total_healthy;
                        }
                    }
                    else
                        Saved_Grid[_X - Grid_Min.X, y - Grid_Min.Y, z - Grid_Min.Z] = Grid.CubeExists(pos) ? BlockState.Normal : BlockState.Empty;
                }
            }
            yield return true;
        }
        DiagHull = total > 0 ? total_healthy * 100 / total : 100;
    }
    RectangleF _Canvas = new RectangleF(-320, -160, 640, 320);

    IEnumerable<bool> Draw(Rotation Rotate)
    {
        Vector3I _Scale = Grid_Max - Grid_Min;
        Vector3I _SpriteSize = Rotate(Grid_Max - Grid_Min, _Scale * 2);
        float _ScaleF = Math.Min(_Canvas.Width, _Canvas.Height) / Math.Max(_SpriteSize.X, _SpriteSize.Y);
        float _OffsetX = (_Canvas.Width - _SpriteSize.X * _ScaleF) * 0.5f + _Canvas.X;
        float _OffsetY = (_Canvas.Height - _SpriteSize.Y * _ScaleF) * 0.5f + _Canvas.Y;
        for (int _X = 0; _X <= _SpriteSize.X; _X++)
            for (int _Y = 0; _Y <= _SpriteSize.Y; _Y++)
                Tiles[_X, _Y] = new TileState();
        for (int _X = Grid_Min.X; _X < Grid_Max.X; ++_X)
        {
            for (int _Y = Grid_Min.Y; _Y < Grid_Max.Y; ++_Y)
            {
                for (int _Z = Grid_Min.Z; _Z < Grid_Max.Z; ++_Z)
                {
                    BlockState state = Saved_Grid[_X - Grid_Min.X, _Y - Grid_Min.Y, _Z - Grid_Min.Z];
                    if (state != BlockState.Empty)
                    {
                        Vector3I pos = new Vector3I(_X, _Y, _Z);
                        Vector3I poscube = Rotate(pos - Grid_Min, _Scale);
                        TileState _MyTile = Tiles[poscube.X, poscube.Y];
                        _MyTile.Depth = Math.Max(_MyTile.Depth, poscube.Z);
                        _MyTile.Total++;
                        if (state == BlockState.Normal)
                            _MyTile.Healthy++;
                        Tiles[poscube.X, poscube.Y] = _MyTile;
                    }
                }
            }
            yield return true;
        }
        Sprites[0] = new List<MySprite>();
        for (int _Y = 0; _Y <= _SpriteSize.Y; _Y++)
        {
            int _Length = 1;
            for (int _X = 0; _X <= _SpriteSize.X; _X++)
            {
                if (_Length != 1) { _Length--; }
                else
                {
                    TileState _MyTile = Tiles[_X, _Y];
                    if (_MyTile.Total == 0)
                        continue;
                    try
                    {
                        bool check = true;
                        while (check)
                            if (_MyTile.Healthy == Tiles[_X + _Length, _Y].Healthy && _MyTile.Depth == Tiles[_X + _Length, _Y].Depth) { _Length++; }
                            else
                            { check = false; }
                    }
                    finally
                    {
                        float depth = ((float)_MyTile.Depth / (float)_SpriteSize.Z);
                        depth = depth * depth * depth * depth + 0.05f;
                        float health = _MyTile.Healthy / (float)_MyTile.Total;
                        if (_MyTile.Healthy < _MyTile.Total)
                            health *= 0.5f;
                        Sprites[0].Add(new MySprite(SpriteType.TEXTURE, "SquareSimple", new Vector2(_X * _ScaleF + _OffsetX + ((_ScaleF / 2) * (_Length - 1)), _Y * _ScaleF + _OffsetY), new Vector2(_ScaleF * _Length, _ScaleF), new Color(depth, depth * health, depth * health)));
                    }
                }
            }
            yield return true;
        }
        Sprites[4] = new List<MySprite>();
        Sprites[22] = new List<MySprite>();
        Stat++;
        for (int i = 0; i < TerminalBlocks.Count; ++i)
        {
            var B = TerminalBlocks[i].Block;
            Vector3I poscube = Rotate(TerminalBlocks[i].Position - Grid_Min, _Scale);
            Vector3I possize = Rotate(TerminalBlocks[i].Size, Vector3I.Zero);
            if (possize.X < 0) { poscube.X += possize.X + 1; possize.X = -possize.X; }
            if (possize.Y < 0) { poscube.Y += possize.Y + 1; possize.Y = -possize.Y; }
            if (possize.Z < 0) { poscube.Z += possize.Z + 1; possize.Z = -possize.Z; }
            MySprite Sprite = new MySprite(SpriteType.TEXTURE, "SquareHollow", new Vector2((poscube.X + possize.X * 0.5f - 0.5f) * _ScaleF + _OffsetX, (poscube.Y + possize.Y * 0.5f - 0.5f) * _ScaleF + _OffsetY), new Vector2(possize.X * _ScaleF, possize.Y * _ScaleF), TerminalBlocks[i].State == BlockState.Normal ? Color.Green : TerminalBlocks[i].State == BlockState.Damaged ? Color.Yellow : Color.Red);
            if (B is IMyBatteryBlock) { if (Sprites[6] == null) Sprites[6] = new List<MySprite>(); Sprites[6].Add(Sprite); }
            else if (B is IMyPowerProducer) { if (Sprites[5] == null) Sprites[5] = new List<MySprite>(); Sprites[5].Add(Sprite); }
            else
                Sprites[22].Add(Sprite);
            if (i % 60 == 0) yield return true;
        }
        Sprites[0].Add(new MySprite(SpriteType.TEXT, $"Ship diagnostic V1.5\nSprite Count:{Sprites[0].Count}\n{DiagStatus}", new Vector2(-310f, -150f), null, Color.White, "Monospace", TextAlignment.LEFT, .4f));
        yield return true;
    }
    public IEnumerable<bool> RunDiag(int R)
    {
        Sprites = new List<List<MySprite>>(new List<MySprite>[23]);
        Stat++;
        foreach (bool val in CheckGrid(true))
            yield return val;
        int terminal_healthy = 0;
        Stat++;
        int Count = 0;
        for (int i = 0; i < TerminalBlocks.Count; ++i)
        {
            bool exists = Grid.CubeExists(TerminalBlocks[i].Position);
            bool working = TerminalBlocks[i].Block.IsWorking;
            if (exists)
                ++terminal_healthy;
            TerminalBlockState s = TerminalBlocks[i];
            s.State = exists && working ? BlockState.Normal : exists ? BlockState.Damaged : BlockState.Missing;
            TerminalBlocks[i] = s;
            Count++;
            if (Count % 60 == 0)
            {
                yield return true;
            }
        }
        Stat++;
        int DiagSystems = TerminalBlocks.Count > 0 ? terminal_healthy * 100 / TerminalBlocks.Count : 100;
        DiagStatus = string.Format($"Hull Integrity:{DiagHull:0}%\nSystems Integrity: {DiagSystems:0}%");
        Rotation Rotate = Bit[R];
        foreach (bool val in Draw(Rotate))
            yield return val;
        Stat++;
    }
    public List<MySprite> Sensor(int R, List<IMyTerminalBlock> SensorList)
    {
        List<MySprite> sprites = new List<MySprite>();
        Rotation Rotate = Bit[R];
        Vector3I _Scale = Grid_Max - Grid_Min;
        Vector3I _SpriteSize = Rotate(Grid_Max - Grid_Min, _Scale * 2);

        float _ScaleF = Math.Min(_Canvas.Width, _Canvas.Height) / Math.Max(_SpriteSize.X, _SpriteSize.Y);
        float _OffsetX = (_Canvas.Width - _SpriteSize.X * _ScaleF) * 0.5f + _Canvas.X;
        float _OffsetY = (_Canvas.Height - _SpriteSize.Y * _ScaleF) * 0.5f + _Canvas.Y;

        List<MyDetectedEntityInfo> entities = new List<MyDetectedEntityInfo>();
        foreach (IMyTerminalBlock Sensor in SensorList)
        {
            ((IMySensorBlock)Sensor).DetectedEntities(entities);
            foreach (MyDetectedEntityInfo entity in entities)
            {
                var EntityPos = Grid.WorldToGridInteger(entity.Position);
                Vector3I pos = new Vector3I(EntityPos.X, EntityPos.Y, EntityPos.Z);
                Vector3I Entity = Rotate(pos - Grid_Min, _Scale);

                sprites.Add(new MySprite(SpriteType.TEXTURE, (entity.Type == MyDetectedEntityType.CharacterHuman || entity.Type == MyDetectedEntityType.CharacterOther) ? "Circle" : (entity.Type == MyDetectedEntityType.LargeGrid || entity.Type == MyDetectedEntityType.SmallGrid) ? "TriangleHollow" : "Danger",
                    new Vector2(Entity.X * _ScaleF + _OffsetX, Entity.Y * _ScaleF + _OffsetY),
                    (entity.Type == MyDetectedEntityType.CharacterHuman || entity.Type == MyDetectedEntityType.CharacterOther) ? new Vector2(_ScaleF, _ScaleF) : new Vector2(2 * _ScaleF, 2 * _ScaleF),
                    entity.Relationship == MyRelationsBetweenPlayerAndBlock.Friends ? Color.Green : entity.Relationship == MyRelationsBetweenPlayerAndBlock.Owner ? Color.Cyan : entity.Relationship == MyRelationsBetweenPlayerAndBlock.Neutral ? Color.Yellow : entity.Relationship == MyRelationsBetweenPlayerAndBlock.FactionShare || entity.Relationship == MyRelationsBetweenPlayerAndBlock.Friends ? Color.Green : Color.Red));
            }
        }
        return sprites;
    }
}

public class TimeAgo
{
    public String Time;
    public TimeAgo(DateTime Reference)
    {
        string R = string.Empty;
        var T = DateTime.Now.Subtract(Reference);
        if (T <= TimeSpan.FromSeconds(60))
        {
            R = string.Format("{0} seconds", T.Seconds);
        }
        else if (T <= TimeSpan.FromMinutes(60))
        {
            R = T.Minutes > 1 ?
                String.Format("{0} minutes", T.Minutes) :
               "a minute";
        }
        else if (T <= TimeSpan.FromHours(24))
        {
            R = T.Hours > 1 ?
                String.Format("{0} hours", T.Hours) :
               "an hour";
        }
        else if (T <= TimeSpan.FromDays(30))
        {
            R = T.Days > 1 ?
                String.Format("{0} days", T.Days) :
               "a day";
        }
        else if (T <= TimeSpan.FromDays(365))
        {
            R = T.Days > 30 ?
                String.Format("{0} months", T.Days / 30) :
               "a month";
        }
        else
        {
            R = T.Days > 365 ?
                String.Format("{0} years", T.Days / 365) :
               "a year";
        }
        Time = $"About {R} ago";
    }
}


